/**
 * 单例模式是一种创建型设计模式，
 * 它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。<br>
 * 三个必要条件<br>
 * 1.私有构造函数<br>
 * 2.一个私有的静态变量存储其唯一实例。<br>
 * 3.提供一个公开的静态方法，使外部使用者可以访问类的唯一实例。<br>
 * 应用场景
 * 控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等
 * <p>
 * <strong>饿汉式单例</strong><br>
 * 只在类加载的时候创建一次实例<br>
 * 优点：线程安全；获取单例对象时不需要加锁。<br>
 * 缺点：不是延时加载，没有用到也会创建，而且在类加载之后就被创建，内存浪费。<br>
 * <p>
 * <strong>懒汉式单例</strong><br>
 * 支持延时加载，获取对象时创建对象。<br>
 * 优点：对象的创建是线程安全的；支持延时加载。<br>
 * 缺点：获取对象的操作需要加锁，影响并发性能。<br>
 * （未加锁的懒汉式线程不安全，多线程不能正常工作，严格意义上并不算单例模式）<br>
 * <p>
 * <strong>双检锁</strong><br>
 * 采用双锁机制，安全且高性能。<br>
 * 懒汉式的改进，将懒汉式中的synchronized方法改成synchronized代码块<br>
 * 先判断instance是否已经被实例化，没有被实例化时才对实例化语句进行加锁。<br>
 * volatile禁止指令重排序，保证了先初始化对象再赋值给instance变量。<br>
 * 优点：对象的创建是线程安全的；支持延时加载；获取对象时不需要加锁。<br>
 * <p>
 * <strong>静态内部类</strong><br>
 * 在内部类里面创建对象实例<br>
 * 只有当调用getInstance()方法时，内部类才会被加载，创建Instance。<br>
 * 与饿汉模式一样，利用类初始化机制<br>
 * Instance 的唯一性、创建过程的线程安全性，由 JVM 来保证。<br>
 * 优点：对象的创建线程安全；支持延时加载；获取对象时不需要加锁。<br>
 * <p>
 * <strong>枚举</strong><br>
 * 实现单例模式的最佳方法。<br>
 * 它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。<br>
 */

package singletonPattern;