### 面向对象设计原则

**里氏替换原则**（Liskov Substitution Principle, LSP）<br>
任何父类可以出现的地方，子类也一定可以出现。
子类在扩展父类的功能时，不应改变父类原有的行为。<br>
例如，如果有一个方法接受一个父类对象作为参数，那么传入该方法的任何子类对象也都应该能使得方法正常工作。

**单一职责原则**（Single Responsibility Principle, SRP）<br>
一个类有且仅有一个改变其的理由，即一个类只负责一项职责。

**开闭原则**（Open-Closed Principle, OCP）<br>
对扩展开放，对修改关闭。
设计时应该易于扩展，添加新功能时，尽量不修改现有代码，而是通过添加新代码来实现。

**接口隔离原则**（Interface Segregation Principle, ISP）<br>
指客户端不应该依赖它不需要的接口。这意味着设计接口时尽量细化接口，接口中的方法尽量少。

**依赖倒置原则**（Dependency Inversion Principle, DIP）<br>
指高层模块不应该依赖低层模块，二者都应该依赖其抽象；
抽象不应该依赖细节，细节应该依赖抽象。设计时应针对接口编程，而不是实现类。

**迪米特法则**<br>
一个软件模块或对象应尽可能少的与其他模块或对象发生相互作用。

### 设计模式

可分为三大类：创建型模式、结构型模式、行为型模式<br>
**创建型模式**：（提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。）<br>
工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式<br>

**结构型模式**：（如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。）<br>
适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式、代理模式<br>

**行为型模式**：（负责对象间的高效沟通和职责委派。）<br>
责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式、访问者模式<br>

#### 单例模式

单例模式是一种创建型设计模式，
它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。<br>
三个必要条件<br>
1.私有构造函数<br>
2.一个私有的静态变量存储其唯一实例。<br>
3.提供一个公开的静态方法，使外部使用者可以访问类的唯一实例。<br>
应用场景
控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等

<strong>饿汉式单例</strong><br>
只在类加载的时候创建一次实例<br>
优点：线程安全；获取单例对象时不需要加锁。<br>
缺点：不是延时加载，没有用到也会创建，而且在类加载之后就被创建，内存浪费。<br>

<strong>懒汉式单例</strong><br>
支持延时加载，获取对象时创建对象。<br>
优点：对象的创建是线程安全的；支持延时加载。<br>
缺点：获取对象的操作需要加锁，影响并发性能。<br>
（未加锁的懒汉式线程不安全，多线程不能正常工作，严格意义上并不算单例模式）<br>

<strong>双检锁</strong><br>
采用双锁机制，安全且高性能。<br>
懒汉式的改进，将懒汉式中的synchronized方法改成synchronized代码块<br>
先判断instance是否已经被实例化，没有被实例化时才对实例化语句进行加锁。<br>
volatile禁止指令重排序，保证了先初始化对象再赋值给instance变量。<br>
优点：对象的创建是线程安全的；支持延时加载；获取对象时不需要加锁。<br>

<strong>静态内部类</strong><br>
在内部类里面创建对象实例<br>
只有当调用getInstance()方法时，内部类才会被加载，创建Instance。<br>
与饿汉模式一样，利用类初始化机制<br>
Instance 的唯一性、创建过程的线程安全性，由 JVM 来保证。<br>
优点：对象的创建线程安全；支持延时加载；获取对象时不需要加锁。<br>

<strong>枚举</strong><br>
实现单例模式的最佳方法。<br>
它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。<br>

#### 工厂模式

